# Session Summary — Sistema de Irrigação Seletiva Linear v1.0

## Session Date: 2026-02-18

---

## Project State at Session End

**Status:** Interface web funcional com PLLController implementado. Sistema pronto para testes em campo no Raspberry Pi 5.

---

## From This Session

### Structural Decisions Made

1. **Flask + subprocesso:** `app.py` gerencia `detector_unificado.py` como subprocesso separado, comunicação via `data/data.json`. Isso permite reiniciar o detector sem derrubar o servidor web e facilita o deploy na Raspberry Pi.

2. **PLLController como classe dedicada:** O PLL foi encapsulado em uma classe dentro de `detector_unificado.py`, com métodos `on_detection()` e `_pll_fire()`. Isso torna o código mais testável e mantém clara a separação entre lógica de detecção e lógica de sincronismo.

3. **Debounce interno ao PLL:** O debounce (40% do período) foi implementado dentro do `PLLController.on_detection()`, não no loop principal. Decisão: manter a lógica de rejeição de detecções duplicadas próxima ao estado do PLL.

4. **Slew rate limiter (`max_corr`):** Limita a variação máxima do período por detecção. Default 20% (corrigido de 10% após análise — 10% era muito restritivo para variações de velocidade do trator). Parâmetro passado via CLI.

5. **Parada na perda de sincronismo:** Após 3 disparos consecutivos sem detecção real, o PLL para de acionar a válvula e sinaliza `pll_sync_lost = true`. Re-sincroniza automaticamente na próxima detecção real.

6. **Interface web 3 colunas:** Layout redesenhado para mostrar: [contador de mudas | volume do tanque | velocidade do trator] em linha, câmera centralizada abaixo, botões de ação abaixo da câmera, alerta de perda de sincronismo PLL em destaque.

### Content Choices Finalized

- **Parâmetros expostos na UI:** modo, limiar, delay, distancia, volume_tanque, volume_irrigacao, max_corr. Todos passados como args para o subprocesso.
- **ROI configurável:** clique e arraste na imagem da câmera para definir ROI; salva em `data/roi_config.json`; persiste entre sessões.
- **Acionamento manual da válvula:** botão na interface para testes sem detecção.
- **Cálculo de velocidade:** `3.6 × distancia / period` (km/h), exibido na UI em tempo real.

### Problems Identified and Solved

- **Problema:** Múltiplas detecções do mesmo objeto em frames consecutivos geravam irrigações duplicadas.
  **Solução:** Debounce de 40% do período estimado dentro do PLLController.

- **Problema:** Variações abruptas de velocidade do trator causavam período PLL instável.
  **Solução:** Filtro IIR (α=0.3) + slew rate limiter (max_corr) para suavizar atualizações de período.

- **Problema:** GPIO no Raspberry Pi 5 usa chip 4, diferente dos modelos anteriores.
  **Solução:** Código tenta chip 4 primeiro, fallback para chip 0.

- **Problema:** `static/live.jpg` sendo servido como arquivo estático causava caching no browser.
  **Solução:** Endpoint `/video_feed` com MJPEG stream e timestamp na URL da imagem para forçar refresh.

### Ideas Explored but Rejected

- **WebSocket para dados em tempo real:** Rejeitado por complexidade de deploy na Raspberry Pi. Polling HTTP a cada 1s é suficiente para os requisitos.
- **SQLite para histórico de irrigações:** Rejeitado por enquanto — `data.json` simples atende a necessidade imediata. Pode ser adicionado futuramente.
- **Modo multiclass (eucalipto + madeira):** O modelo suporta 2 classes, mas o sistema de irrigação usa apenas detecções de eucalipto por ora. Madeira pode ser filtrada como obstáculo no futuro.

---

## Combined Context

### How Session Decisions Align with Project Vision

O objetivo é um sistema embarcado que rode na Raspberry Pi 5 no campo, sem necessidade de operador técnico. As decisões de arquitetura (subprocesso, arquivo JSON, interface simples) priorizam robustez e facilidade de manutenção em ambiente rural.

### Tensions to Resolve Next Time

1. **Teste real em campo:** O sistema foi desenvolvido e testado em PC (Linux x86). Precisa de validação no Raspberry Pi 5 com câmera RTSP real e GPIO conectado.
2. **Calibração do PLL:** Os valores de `max_corr` (20%), `alpha` (0.3) e debounce (40%) são estimativas teóricas. Precisam de ajuste com dados reais de velocidade do trator.
3. **Consumo de CPU:** O modo `balanced` (PyTorch) pode ser pesado para o Raspberry Pi 5. Considerar modo `int8` como default em produção.
4. **Overflow do tank volume:** Não há proteção contra volume negativo se o sistema rodar muito tempo sem reset.

### Evolution of the Concept

- **Início:** Script simples de detecção com saída no terminal.
- **Meio:** Adição de GPIO e contador de mudas.
- **Fim desta sessão:** Sistema completo com interface web, PLL sincronizado, ROI configurável e múltiplos modos de inferência.

---

## Next Steps (Priority Order)

1. Deploy e teste na Raspberry Pi 5 com câmera e GPIO reais
2. Calibrar parâmetros PLL com dados de campo
3. Avaliar consumo de CPU no Pi 5 e ajustar modo de inferência default
4. Adicionar proteção contra volume negativo do tanque
5. Considerar logging de irrigações para análise posterior

---

## Key Files Modified This Session

| Arquivo | Mudança |
|---|---|
| `app.py` | Criado do zero — servidor Flask completo |
| `detector_unificado.py` | PLLController adicionado; parâmetros distancia, volume_tanque, volume_irrigacao, max_corr |
| `templates/index.html` | Redesign completo: 3 colunas, alerta PLL |
| `static/style.css` | Estilos da nova interface |
| `CLAUDE.md` | Documentação completa do projeto |
| `.claude/agents/script-session-closer.md` | Agente de fechamento de sessão |
| `.gitignore` | Exclusões para venv, modelos, arquivos runtime |
